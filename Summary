ğŸª ShopVerse â€” Event-Driven E-Commerce Backend
ğŸ”¹ What It Is

ShopVerse is a microservices-based, event-driven e-commerce backend system.
Users can register/login, browse/search products, place orders, process payments asynchronously, and receive notifications â€” all handled by independent services communicating via Apache Kafka.

Built like a real production system â€” includes caching, full-text search, rate limiting, circuit breakers, tests, Docker, CI/CD, and AWS deployment.

ğŸ’¡ Why It Matters (Significance)
TL;DR

ShopVerse mirrors how modern product companies build scalable, resilient, observable backend systems.

Real-World Value

âœ… Demonstrates production-grade architecture â€” microservices, async messaging, observability, CI/CD.

âœ… Covers key backend pillars: Java internals, Spring ecosystem, databases (SQL + NoSQL), Kafka, Redis, ElasticSearch, AWS.

âœ… Shows end-to-end request flow and async system design (higher throughput, decoupled reliability).

âœ… Strong portfolio project â€” great interview talking point for product or distributed systems roles.

ğŸ§© Core Components & Technologies
Component	Technology	Purpose / Why Used
Language & Framework	Java 17 + Spring Boot 3	Dependency Injection, Web APIs, Data Access
User Data	PostgreSQL	ACID-compliant transactional store
Product Catalog	MongoDB	Flexible schema, fast writes
Search	ElasticSearch	Full-text, fuzzy, relevance-based search
Caching / Rate Limiting	Redis	Speed + rate control for gateway & hot reads
Event Bus	Apache Kafka	Decoupled async communication between services
Gateway	Spring Cloud Gateway	Routing, JWT validation, rate limiting
Auth	Spring Security + JWT	Authentication & authorization
Resilience	Resilience4J	Circuit breaker, retry, bulkhead
Testing	JUnit + Mockito	Unit & integration tests
Containers	Docker + Compose	Reproducible local environment
CI/CD	GitHub Actions	Automated build/test/deploy
Deployment	AWS EC2 (+ RDS/S3)	Cloud hosting
Monitoring	Prometheus + Grafana + Actuator	Metrics, dashboards, observability
âš™ï¸ Detailed End-to-End Flow
1ï¸âƒ£ API Gateway (Spring Cloud Gateway + Redis RateLimiter)

Routes requests (/users, /products, /orders, etc.)

Validates JWTs, applies rate limits.

Improves security & protects backend from overload.

2ï¸âƒ£ User Service (PostgreSQL)

Endpoints: /users/register, /users/login, /users/{id}

Handles user registration, login, and JWT issuance.

Stores user credentials & roles in relational DB.

3ï¸âƒ£ Product Service (MongoDB + ElasticSearch + Redis)

Endpoints: /products, /products/{id}, /products/search?q=...

Stores products in MongoDB, indexes them in ElasticSearch.

Caches frequent reads in Redis for fast access.

4ï¸âƒ£ Order Service (PostgreSQL + Kafka Producer)

Endpoint: POST /orders

Validates user & product IDs.

Saves order with status PENDING.

Publishes order-created event to Kafka â†’ triggers async processing.

5ï¸âƒ£ Payment Service (Kafka Consumer)

Subscribes to order-created topic.

Simulates payment (success/failure).

Updates order status (SUCCESS / FAILED) via REST or payment-status Kafka event.

6ï¸âƒ£ Notification Service (Kafka Consumer)

Listens to order-created & payment-status topics.

Sends appropriate notifications (mocked / logged).

Fully decoupled from order/payment flow.

7ï¸âƒ£ Caching & Rate Limiting (Redis)

Cache: Hot product reads â†’ reduced DB load.

Rate limit: Controls user/IP request frequency at gateway level.

8ï¸âƒ£ Security (Spring Security + JWT)

Centralized authentication (JWT generation at login).

Distributed authorization (role-based via annotations).

Tokens validated at gateway â†’ forwarded to microservices.

9ï¸âƒ£ Resilience (Resilience4J)

Circuit breakers protect from downstream failures.

Example: If Payment Service fails, Order Service falls back safely.

Ensures reliability & graceful degradation.

ğŸ”Ÿ Deployment & DevOps
Docker + Docker Compose

Each service containerized.

docker-compose up -d â†’ runs complete system locally.

AWS EC2 Deployment

Clone repo, run via Docker Compose on cloud.

Public IP accessible â€” real-world hosting experience.

GitHub Actions CI/CD

Auto build + test on every push.

Optional SSH deploy to AWS.

1ï¸âƒ£1ï¸âƒ£ Monitoring & Observability

Spring Actuator exposes metrics.

Prometheus scrapes data.

Grafana visualizes dashboards (CPU, latency, requests, etc.).

Enables proactive system monitoring.

ğŸ” System Flow Summary
Client
  â†“
Gateway (JWT + RateLimit)
  â†“
User Service â†’ PostgreSQL
  â†“
Product Service â†’ MongoDB â†’ ElasticSearch
  â†“
Order Service â†’ PostgreSQL â†’ Kafka (order-created)
  â†“
Payment Service (Kafka consumer) â†’ Kafka (payment-status)
  â†“
Notification Service (Kafka consumer)
  â†“
Redis (shared cache)
  â†“
Docker â†’ GitHub Actions â†’ AWS EC2

ğŸŒŸ Significance Summary
Goal	Technology	Why It Matters
Scalability	Microservices + Kafka	Independent scaling & async processing
Speed	Redis caching	Sub-ms reads, reduced DB load
Reliability	Resilience4J + Kafka	Graceful degradation & decoupling
Security	JWT + Gateway	Real auth/authz flow
Observability	Prometheus + Grafana	Real-time metrics & dashboards
Portability	Docker + Compose	Consistent local + cloud setup
Deployment	AWS + GitHub Actions	CI/CD with real cloud deployment
